<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>marginpadding</title>
    <style lang="text/css">
        * {
            margin: 0;
            padding: 0;
        }
        p {
            margin-top: 10px;
            margin-bottom: 15px;
            /* border: 1px solid #000; */
        }
    </style>
</head>
<body>
    <!-- 该题中dp1同dp2的距离为15px -->
    <!-- 如果设置边框，或者中间的p不为空，距离则变成45px -->
    <!-- <p id="dp1">AAA</p>
    <P>CCC</P>
    <P>CCC</P>
    <P>CCC</P>
    <p id="dp2">BBB</p> -->
    <p id="dp1">AAA</p>
    <P></P>
    <P></P>
    <P></P>
    <p id="dp2">BBB</p>
</body>
<script>
    const Dp1 = document.getElementById('dp1')
    console.dir(Dp1);
    // 對於P标签DOM层级如下
    // Dp1 => HTMLParagraphElement => HTMLElement => Element => Node => EventTarget => Object 
    // 對於Div标签DOM层级如下
    // Div => HTMLDivElement => HTMLElement => Element => Node => EventTarget => Object 
    const Dp2 = document.getElementById('dp2')
    const Dp1data = window.getComputedStyle(Dp1)
    // offsetTop為元素到父元素頂部的距離，offsetHeight為盒子的實際高度
    // clientWidth = width + padding
    // clientHeight = height + padding
    // clientTop = border-top width
    // clientLeft = border-left width
    // 如果盒子中的内容有溢出，clientWidth clientHeight不变，
    // offsetWidth = width + padding + border
    // offsetHeight = width + padding + border
    // offsetParent代表父元素的参照物 offset的值都是相对他的变化
    // scrollWidth/scrollHeight 在盒子不溢出的情况下同clientWidth/clientHeight一样
    // 如果溢出的情况下 scrollWidth 等于真实内容宽度加上左填充 scrollHeight等于真实内容高度加上上填充
    // 而scrollTop和scrollLeft表示滑动条移动的距离
    // Dp1同Dp2的距離就是如下 Dp2距離父元素的高度，減去Dp1距離父元素的高度，和Dp1的盒子高度
    const distance = Dp2.offsetTop - Dp1.offsetTop - Dp1.offsetHeight
    console.log(distance)
    // console.log(Dp1.offsetTop,Dp1.offsetHeight)
    // console.log(Dp1.offsetTop,Dp1.offsetHeight)
    // console.log(Dp2.offsetTop,Dp2.offsetHeight)
    
</script>
<script>
    function getcssstyle(el, attr) {
    // 对于传进来的attr参数也需要进行兼容处理，一些属性如opacity
    let val = null
    // 考虑到各种变量的val格式不一样 需要进行分类表示处理。该reg表示 数字+单位形式的结果
    // 这些均可以使用parseFloat来处理直接获取数值。
    let reg = /^(-?\d+(\.\d+)?)(px|pt|rem|em)?$/i
    //判断getComputedStyle这个方法是否在window中，如果有就使用这个方法
    if ('getComputedStyle' in window) {
        val = window.getComputedStyle(el, null)[attr]
    }else  {//对于IE 6 7 8使用下面的使用currentStyle
        if(attr === 'opacity') {
            val = el.currentStyle['filter']
            // 此时结果是alpha(opacity=10)()里面的需要捕获 ？：表示只匹配不捕获
            reg = /(\d+(?:\.\d+)?)/i
            val = parseFloat(val.match(reg)[0])/100
            return val
            
        }else {
            val = el.currentStyle[attr]
        }
    }
    if (reg.test(val)) {
        val = parseFloat(val)
    }
    return val
}
    console.log(getcssstyle(Dp1, 'width'))
    console.log(getcssstyle(Dp1, 'margin'))
    console.log(getcssstyle(Dp1, 'padding'))
    
</script>
</html>