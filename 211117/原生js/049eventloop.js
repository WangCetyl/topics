/*
    https://my.oschina.net/u/4088983/blog/4546263
    Call Stack：调用栈(执行栈)，所有同步任务在主线程上执行，形成一个执行栈，因为 JS 单线程的原因，所以调用栈中每次只能
    执行一个任务，当遇到的同步任务执行完之后，由任务队列提供任务给调用栈执行。
    Task Queue：任务队列，存放着异步任务，当异步任务可以执行的时候，任务队列会通知主线程，然后该任务会进入主线程执行。
    任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中。
    说到这里，Event Loop 也可以理解为：不断地从任务队列中取出任务执行的一个过程。
    同步任务和异步任务
    上文已经说过了 JavaScript 是一门单线程的语言，一次只能执行一个任务，如果所有的任务都是同步任务，那么程序可能因为
    等待会出现假死状态，这对于一个用户体验很强的语言来说是非常不友好的。
    比如说向服务端请求资源，你不可能一直不停的循环判断有没有拿到数据，就好像你点了个外卖，点完之后就开始一直打电话问外
    卖有没有送到，外卖小哥都会抄着锅铲来打你(狗头)。因此，在 JavaScript 中任务有了同步任务和异步任务，异步任务通过注册
    回调函数，等到数据来了就通知主程序。

    概念
    简单的介绍一下同步任务和异步任务的概念。
    同步任务：必须等到结果来了之后才能做其他的事情，举例来说就是你烧水的时候一直等在水壶旁边等水烧开，期间不做其他的任
    何事情。
    异步任务：不需要等到结果来了才能继续往下走，等结果期间可以做其他的事情，结果来了会收到通知。举例来说就是你烧水的时
    候可以去做自己想做的事情，听到水烧开的声音之后再去处理。
    从概念就可以看出来，异步任务从一定程度上来看比同步任务更高效一些，核心是提高了用户体验。

    Event Loop
    Event Loop 很好的调度了任务的运行，宏任务和微任务也知道了，现在我们就来看看它的调度运行机制。

    JavaScript 的代码执行时，主线程会从上到下一步步的执行代码，同步任务会被依次加入执行栈中先执行，异步任务会在拿到
    结果的时候将注册的回调函数放入任务队列，当执行栈中的没有任务在执行的时候，引擎会从任务队列中读取任务压入执行栈(Call
     Stack)中处理执行。

    宏任务和微任务
    现在就有一个问题了，任务队列是一个消息队列，先进先出，那就是说，后来的事件都是被加在队尾等到前面的事件执行完了才会
    被执行。如果在执行的过程中突然有重要的数据需要获取，或是说有事件突然需要处理一下，按照队列的先进先出顺序这些是无法
    得到及时处理的。这个时候就催生了宏任务和微任务，微任务使得一些异步任务得到及时的处理。

    曾经看到的一个例子很好，宏任务和微任务形象的来说就是：你去营业厅办一个业务会有一个排队号码，当叫到你的号码的时候你
    去窗口办充值业务(宏任务执行)，在你办理充值的时候你又想改个套餐(微任务)，这个时候工作人员会直接帮你办，不可能让你
    重新排队。

    所以上文说过的异步任务又分为宏任务和微任务，JS 运行时任务队列会分为宏任务队列和微任务队列，分别对应宏任务和微任务。

    先介绍一下(浏览器环境的)宏任务和微任务大致有哪些：

    宏任务：
    script(整体的代码)
    setTimeout
    setInterval
    I/O 操作
    UI 渲染 (对这个笔者持保留意见)
    微任务：
    Promise.then
    MutationObserver
    事件运行顺序
    执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) --- 第一轮从 script开始
    从宏任务队列中取出队头任务执行
    如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行
    如果产生了微任务，将微任务放入微任务队列
    执行完当前宏任务之后，取出微任务队列中的所有任务依次执行
    如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空
    轮循，循环以上 2 - 6
    总的来说就是：同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 同步任务/宏任务 -> 执行产生的所
    有微任务(包括微任务产生的微任务) -> 循环......
    注意：微任务队列
 */

{
  console.log('script start')
  setTimeout(function() {
    console.log('setTimeout')
  }, 0)
  new Promise((resolve, reject)=>{
    console.log("promise1")
    resolve()
  })
  .then(()=>{
    console.log("then11")
    new Promise((resolve, reject)=>{
      console.log("promise2")
      resolve();
    })
    .then(() => {
      console.log("then2-1")
    })
    .then(() => {
      console.log("then2-2")
    })
  })
  .then(()=>{
    console.log("then12")
  })
  console.log('script end')
/*
    首先遇到 console.log()，输出 script start
    遇到 setTimeout 产生宏任务，注册到 宏任务队列[setTimeout]，下一轮 Event Loop 的时候在执行
    然后遇到 new Promise 构造声明(同步)，log 输出 promise1，然后 resolve
    resolve 匹配到 promise1 的第一个 then，把这个 then 注册到 微任务队列[then11]中，继续当前整体脚本的执行
    遇到最后的一个 log，输出 script end， 当前执行栈清空
    从微任务队列中取出队头任务'then11' 进行执行，其中有一个 log，输出 then11
    往下遇到 new Promise 构造声明(同步)，log 输出 promise2，然后 resolve
    resolve 匹配到 promise2 的第一个 then，把这个 then 注册到 微任务队列[then2-1]，当前 then11 可执行部分结束，然后产生了 promise1 的第二个 then，把这个 then 注册到 微任务队列[then2-1, then12]
    拿出微任务队头任务'then2-1' 执行，log 输出 then2-1，触发 promise2 的第二个 then，注册到 微任务队列[then12, then2-2]
    拿出微任务队头任务'then12'，log 输出 then12
    拿出微任务队头任务'then2-2'，log 输出 then2-2
    微任务队列执行完毕，别忘了宏任务队列中的 setTimeout，log 输出 setTimeout
    经过以上一番缜(xia)密(gao)分析，希望没有绕晕你，最后的输出结果就是：
    script start -> promise1 -> script end -> then11 -> promise2 -> then2-1 -> then12 -> then2-2 -> setTimeout
*/

}




